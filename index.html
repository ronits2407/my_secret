<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Harry Potter: Surrounded by Death Eaters</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
      cursor: none;
    }
    #background {
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      z-index: 0;
      object-fit: cover;
      pointer-events: none;
      user-select: none;
    }
    #gameCanvas {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1;
      background: transparent;
      display: block;
      margin: 0 auto;
      border-radius: 0;
    }
    #scoreboard {
      color: #000;
      font-family: 'Segoe UI', Arial, sans-serif;
      font-size: 1.2em;
      text-align: center;
      margin: 12px 0;
      z-index: 2;
      position: relative;
    }
    #levelDisplay {
      color: #000;
      font-family: 'Segoe UI', Arial, sans-serif;
      font-size: 1.1em;
      text-align: center;
      margin: 8px 0;
      z-index: 2;
      position: relative;
      font-weight: bold;
    }
    #levelProgress {
      color: #000;
      font-family: 'Segoe UI', Arial, sans-serif;
      font-size: 1em;
      text-align: center;
      margin: 4px 0;
      z-index: 2;
      position: relative;
    }
    audio {
      display: none;
    }
    #startMenu {
      position:fixed; left:0; top:0; width:100vw; height:100vh; 
      background:linear-gradient(135deg, rgba(20,20,40,0.95), rgba(40,20,60,0.95)); backdrop-filter: blur(10px); z-index:10; display:flex; flex-direction:column; 
      align-items:center; justify-content:center; color:#fff; font-family:'Times New Roman',serif;
      border: 2px solid #FFD700;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
    }
    #startMenu button {
      font-size:1.3em; padding:14px 50px; border-radius:12px; border:none; 
      background:linear-gradient(45deg, #7b4c1e, #a67c52); color:#fff; cursor:pointer; box-shadow:0 2px 12px #0008;
      transition: all 0.3s ease;
    }
    #startMenu button:hover {
      transform: translateY(-3px);
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
      background: linear-gradient(45deg, #a67c52, #7b4c1e);
    }
    #gameOverMenu {
      position:fixed; left:0; top:0; width:100vw; height:100vh; 
      background:rgba(20,20,40,0.92); z-index:20; display:none; flex-direction:column; 
      align-items:center; justify-content:center; color:#fff; font-family:'Times New Roman',serif;
    }
    #gameOverText {
      font-size:2.2em; margin-bottom:24px;
    }
    #finalScore {
      font-size:1.3em; margin-bottom:36px;
    }
    #retryBtn {
      font-size:1.3em; padding:14px 50px; border-radius:12px; border:none; 
      background:#7b4c1e; color:#fff; cursor:pointer; box-shadow:0 2px 12px #0008;
    }

    /* Enhanced UI Elements */
    #healthBar {
      position: fixed;
      top: 20px;
      left: 20px;
      width: 200px;
      height: 20px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #FFD700;
      border-radius: 10px;
      z-index: 100;
      overflow: hidden;
    }

    #healthFill {
      height: 100%;
      background: linear-gradient(90deg, #ff0000, #ff6b6b, #ff0000);
      border-radius: 8px;
      transition: width 0.3s ease;
      position: relative;
    }

    #healthFill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      animation: healthShine 2s infinite;
    }

    @keyframes healthShine {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    #levelProgressBar {
      position: fixed;
      top: 50px;
      left: 20px;
      width: 200px;
      height: 15px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #4e9cff;
      border-radius: 8px;
      z-index: 100;
      overflow: hidden;
    }

    #levelProgressFill {
      height: 100%;
      background: linear-gradient(90deg, #4e9cff, #87ceeb, #4e9cff);
      border-radius: 6px;
      transition: width 0.5s ease;
      position: relative;
    }

    #levelProgressFill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      animation: progressShine 1.5s infinite;
    }

    @keyframes progressShine {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    /* Enhanced Score Display */
    #scoreDisplay {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: #FFD700;
      padding: 10px 20px;
      border-radius: 15px;
      border: 2px solid #FFD700;
      font-family: 'Times New Roman', serif;
      font-size: 1.2em;
      z-index: 100;
      animation: scoreGlow 2s infinite alternate;
    }

    @keyframes scoreGlow {
      0% { box-shadow: 0 0 10px #FFD700; }
      100% { box-shadow: 0 0 20px #FFD700, 0 0 30px #FFD700; }
    }

    /* Particle System */
    .particle {
      position: absolute;
      pointer-events: none;
      z-index: 50;
    }

    .spell-particle {
      position: fixed;
      width: 4px;
      height: 4px;
      background: #FFD700;
      border-radius: 50%;
      pointer-events: none;
      z-index: 9997;
      animation: spellFloat 1.5s linear forwards;
    }

    @keyframes spellFloat {
      0% { opacity: 1; transform: translateY(0) scale(1); }
      100% { opacity: 0; transform: translateY(-50px) scale(0.5); }
    }

    .death-particle {
      width: 6px;
      height: 6px;
      background: radial-gradient(circle, #ff0000, #ff6b6b);
      border-radius: 50%;
      animation: deathParticle 1.5s ease-out forwards;
    }

    @keyframes deathParticle {
      0% {
        opacity: 1;
        transform: scale(1);
      }
      100% {
        opacity: 0;
        transform: scale(0.1) translateY(-30px) translateX(var(--random-x));
      }
    }

    .magic-sparkle {
      position: fixed;
      width: 6px;
      height: 6px;
      background: #FFD700;
      border-radius: 50%;
      pointer-events: none;
      z-index: 9996;
      animation: sparkleEffect 1s linear forwards;
    }

    @keyframes sparkleEffect {
      0% { opacity: 1; transform: scale(0) rotate(0deg); }
      50% { opacity: 1; transform: scale(1) rotate(180deg); }
      100% { opacity: 0; transform: scale(0) rotate(360deg); }
    }

    /* Screen Shake Effect */
    .screen-shake {
      animation: shake 0.3s ease-in-out;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }

    /* Level Transition Effect */
    .level-transition {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: radial-gradient(circle, transparent, rgba(0, 0, 0, 0.8));
      z-index: 200;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }

    .level-transition.active {
      opacity: 1;
      pointer-events: all;
    }

    /* Parallax Background */
    .parallax-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: -1;
    }

    .bg-layer-1 {
      background: url('harry potter sky.jpg') no-repeat center center;
      background-size: cover;
      transform: translateZ(-3px) scale(1.5);
    }

    .bg-layer-2 {
      background: url('harry potter forest.jpg') no-repeat center center;
      background-size: cover;
      transform: translateZ(-1px) scale(1.2);
    }

    /* Magic Aura Effect */
    .magic-aura {
      position: absolute;
      width: 100px;
      height: 100px;
      background: radial-gradient(circle, rgba(255, 215, 0, 0.3), transparent);
      border-radius: 50%;
      animation: auraPulse 2s infinite;
    }

    @keyframes auraPulse {
      0%, 100% { transform: scale(1); opacity: 0.3; }
      50% { transform: scale(1.2); opacity: 0.6; }
    }

    /* Achievement Notification */
    .achievement {
      position: fixed;
      top: 40px;
      right: -400px;
      min-width: 280px;
      max-width: 350px;
      background: rgba(20, 10, 40, 0.38);
      box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.18), 0 0 24px 4px #4e9cff66;
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      border-radius: 20px;
      border: 1.5px solid rgba(78, 156, 255, 0.38);
      color: #e0d7ff;
      padding: 28px 32px 24px 32px;
      font-family: 'Segoe UI', 'Times New Roman', serif;
      font-size: 1.25em;
      font-weight: 600;
      z-index: 300;
      opacity: 0;
      pointer-events: none;
      transition: right 0.7s cubic-bezier(.77,0,.18,1), opacity 0.4s;
      display: flex;
      align-items: center;
      gap: 16px;
      box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.18), 0 0 32px 8px #4e9cff44, 0 0 0 2px #FFD70033;
    }
    .achievement.slide-in {
      right: 40px;
      opacity: 1;
      pointer-events: auto;
    }
    .achievement.slide-out {
      right: -400px;
      opacity: 0;
      pointer-events: none;
    }

    .achievement::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      border-radius: 20px;
      background: linear-gradient(120deg, rgba(78,156,255,0.10) 0%, rgba(20,10,40,0.12) 100%);
      pointer-events: none;
      z-index: 1;
      box-shadow: 0 0 24px 8px #FFD70022;
    }

    .achievement .icon {
      font-size: 2em;
      filter: drop-shadow(0 2px 8px #FFD70088) drop-shadow(0 0 6px #4e9cff88);
      z-index: 2;
    }

    .achievement .text {
      z-index: 2;
      text-shadow: 0 1px 8px #000a, 0 0 4px #4e9cff44;
    }

    /* Dynamic Background System */
    .dynamic-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: -1;
      transition: opacity 2s ease-in-out;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }

    .bg-1 {
      background-image: url('background.jpg');
      opacity: 1;
    }

    .bg-2 {
      background-image: url('harry potter forest.jpg');
      opacity: 0;
    }

    .bg-3 {
      background-image: url('harry potter sky.jpg');
      opacity: 0;
    }

    .bg-4 {
      background-image: url('562430.jpg');
      opacity: 0;
    }

    .bg-active {
      opacity: 1 !important;
    }

    /* Harry Potter Themed Custom Cursor */
    .magical-cursor {
      position: fixed;
      width: 24px;
      height: 24px;
      background: radial-gradient(circle, #FFD700, #FFA500);
      border-radius: 50%;
      pointer-events: none;
      z-index: 9999;
      mix-blend-mode: screen;
      box-shadow: 0 0 15px #FFD700, 0 0 30px #FFA500;
      animation: cursorGlow 2s infinite alternate;
    }

    @keyframes cursorGlow {
      0% { box-shadow: 0 0 15px #FFD700, 0 0 30px #FFA500; }
      100% { box-shadow: 0 0 25px #FFD700, 0 0 50px #FFA500, 0 0 75px #FF8C00; }
    }

    .cursor-trail {
      position: fixed;
      width: 8px;
      height: 8px;
      background: radial-gradient(circle, #FFD700, transparent);
      border-radius: 50%;
      pointer-events: none;
      z-index: 9998;
      animation: trailFade 0.8s linear forwards;
    }

    @keyframes trailFade {
      0% { opacity: 0.8; transform: scale(1); }
      100% { opacity: 0; transform: scale(0.3); }
    }

    .sparkle {
      position: fixed;
      width: 6px;
      height: 6px;
      background: #FFD700;
      border-radius: 50%;
      pointer-events: none;
      z-index: 9996;
      animation: sparkleEffect 1s linear forwards;
    }

    @keyframes sparkleEffect {
      0% { opacity: 1; transform: scale(0) rotate(0deg); }
      50% { opacity: 1; transform: scale(1) rotate(180deg); }
      100% { opacity: 0; transform: scale(0) rotate(360deg); }
    }

    /* Show default cursor on interactive elements */
    button, a, input, textarea {
      cursor: none;
    }
  </style>
</head>
<body>
  <!-- Parallax Background Layers -->
  <div class="parallax-bg bg-layer-1"></div>
  <div class="parallax-bg bg-layer-2"></div>
  
  <!-- Dynamic Background System -->
  <div class="dynamic-bg bg-1 bg-active" id="bg1"></div>
  <div class="dynamic-bg bg-2" id="bg2"></div>
  <div class="dynamic-bg bg-3" id="bg3"></div>
  <div class="dynamic-bg bg-4" id="bg4"></div>
  
  <!-- Harry Potter Themed Cursor -->
  <div class="magical-cursor" id="magicalCursor"></div>
  
  <!-- Enhanced UI Elements -->
  <div style="position: fixed; top: 20px; left: 20px; z-index: 101; display: flex; flex-direction: column; gap: 18px;">
    <div style="display: flex; align-items: center; gap: 10px;">
      <div id="healthBar">
        <div id="healthFill" style="width: 100%;"></div>
      </div>
      <span style="font-family: 'Segoe UI', serif; color: #FFD700; font-size: 1em; text-shadow: 0 1px 4px #000a; margin-left: 6px;">Health</span>
    </div>
    <div style="display: flex; flex-direction: column; align-items: flex-start; gap: 0;">
      <div id="levelProgressBar">
        <div id="levelProgressFill" style="width: 0%;"></div>
      </div>
      <span style="font-family: 'Segoe UI', serif; color: #4e9cff; font-size: 1em; text-shadow: 0 1px 4px #000a; margin-top: 8px; margin-left: 2px;">Progress</span>
    </div>
  </div>
  <div id="scoreDisplay">Score: 0</div>
  
  <!-- Level Transition Overlay -->
  <div class="level-transition" id="levelTransition"></div>
  
  <!-- Achievement Container -->
  <div id="achievementContainer"></div>
  
  <div id="scoreboard">Score: 0 &nbsp; | &nbsp; Lives: 3</div>
  <div id="levelDisplay">Level: 1</div>
  <div id="levelProgress">Progress: 0%</div>
  <canvas id="gameCanvas" width="960" height="960"></canvas>
  <audio id="bg-music" src="background.mp3" autoplay loop></audio>
  
  <!-- Enhanced Audio Elements -->
  <audio id="spell-sound" src="magic-spell-6005.mp3"></audio>
  <audio id="teleport-sound" src="magic-teleport-whoosh-352764.mp3"></audio>
  <audio id="success-sound" src="short-success-sound-glockenspiel-treasure-video-game-6346.mp3"></audio>
  <audio id="death-sound" src="dramatic-death-collapse-352720.mp3"></audio>
  
  <div id="startMenu">
    <div style="font-size:2.2em; margin-bottom:24px;">Sasha's Magical Revelation Quest ✨</div>
    <div style="font-size:1.1em; margin-bottom:36px; max-width:500px; text-align:center;">
      <br>
      Get ready for an enchanted quest where every point you earn reveals a secret message from your very own admirer..<br>
      <b>This isn't just any game; it's a magical journey to uncover what's truly been brewing in my heart,<br>
         designed just for you. So, grab your wand, cast your best spells, and prepare to discover a hidden charm! </b>
    </div>
    <button id="startBtn">Start Game</button>
  </div>
  <div id="gameOverMenu">
    <div id="gameOverText">Game Over!</div>
    <div id="finalScore"></div>
    <button id="retryBtn">Retry</button>
  </div>
  <script>
    // Password protection before anything else loads
    (function passwordProtect() {
      var allowed = false;
      while (!allowed) {
        var answer = prompt('What is my fav movie?');
        if (answer && answer.trim().toLowerCase() === 'titanic') {
          allowed = true;
        } else {
          alert('Incorrect! Try again.');
        }
      }
    })();

    // --- Game Variables ---
    let gameStarted = false;
    let gameOver = false;
    let score = 0;
    let lives = 3;
    let currentLevel = 1;
    let levelScore = 0;
    let levelTarget = 15; // Score needed to complete level 1

    // Enhanced variables
    let particles = [];
    let screenShake = 0;
    let lastAchievement = 0;
    let parallaxOffset = 0;
    let currentBgIndex = 0;
    let bgChangeInterval = null;

    // Level configuration
    const levelConfig = {
      1: { target: 15, deathEaterInterval: 2200, witchInterval: 4000, enemySpeed: 0.6, witchSpeed: 0.6 },
      2: { target: 25, deathEaterInterval: 1800, witchInterval: 3200, enemySpeed: 0.8, witchSpeed: 0.8 },
      3: { target: 35, deathEaterInterval: 1400, witchInterval: 2400, enemySpeed: 1.0, witchSpeed: 1.0 }
    };

    // Audio management
    const audioManager = {
      spell: document.getElementById('spell-sound'),
      teleport: document.getElementById('teleport-sound'),
      success: document.getElementById('success-sound'),
      death: document.getElementById('death-sound'),
      
      playSpell() {
        this.spell.currentTime = 0;
        this.spell.volume = 0.4;
        this.spell.play().catch(() => {});
      },
      
      playTeleport() {
        this.teleport.currentTime = 0;
        this.teleport.volume = 0.6;
        this.teleport.play().catch(() => {});
      },
      
      playSuccess() {
        this.success.currentTime = 0;
        this.success.volume = 0.5;
        this.success.play().catch(() => {});
      },
      
      playDeath() {
        this.death.currentTime = 0;
        this.death.volume = 0.3;
        this.death.play().catch(() => {});
      }
    };

    // Images
    function loadImage(src, fallbackColor) {
      const img = new Image();
      img.src = src;
      img.onerror = () => { img.loaded = false; };
      img.onload = () => { img.loaded = true; };
      img.fallbackColor = fallbackColor;
      return img;
    }
    const harryImg = loadImage('harry.png', '#4e9cff');
    const deImg = loadImage('deatheater.png', '#222');
    const spellImg = loadImage('spell.png', '#fff');
    const witchImg = loadImage('witch.png', '#f0e');
    const witchRImg = loadImage('witchr.png', '#f0e');

    // Canvas setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreboard = document.getElementById('scoreboard');

    // Main character
    const harryBaseW = 64, harryBaseH = 64;
    const harryW = harryBaseW * 2, harryH = harryBaseH * 2; // 100% bigger
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    let harry = { x: centerX, y: centerY, w: harryW, h: harryH, speed: 5, angle: 0 };

    // Entities
    let spells = [];
    let deathEaters = [];
    let witches = [];

    // Controls
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      harry.angle = Math.atan2(my - harry.y, mx - harry.x);
    });
    canvas.addEventListener('click', shootSpell);
    document.addEventListener('keydown', e => {
      if (e.key === ' ' || e.key === 'Spacebar') shootSpell();
    });

    function shootSpell() {
      if (gameOver || !gameStarted) return;
      if (spells.length && Date.now() - spells[spells.length-1].created < 200) return;
      const angle = harry.angle;
      spells.push({
        x: harry.x + Math.cos(angle) * 40,
        y: harry.y + Math.sin(angle) * 40,
        w: 16, h: 16,
        speed: 18,
        dx: Math.cos(angle),
        dy: Math.sin(angle),
        created: Date.now()
      });
      
      // Enhanced spell effects
      audioManager.playSpell();
      createSpellParticles(harry.x + Math.cos(angle) * 40, harry.y + Math.sin(angle) * 40);
      // addScreenShake(2); // Removed screen shake
    }

    // Particle System Functions
    function createSpellParticles(x, y) {
      for (let i = 0; i < 8; i++) {
        const particle = {
          x: x + (Math.random() - 0.5) * 20,
          y: y + (Math.random() - 0.5) * 20,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          life: 1,
          type: 'spell'
        };
        particles.push(particle);
      }
    }

    function createDeathParticles(x, y) {
      for (let i = 0; i < 12; i++) {
        const particle = {
          x: x + (Math.random() - 0.5) * 30,
          y: y + (Math.random() - 0.5) * 30,
          vx: (Math.random() - 0.5) * 6,
          vy: (Math.random() - 0.5) * 6,
          life: 1,
          type: 'death'
        };
        particles.push(particle);
      }
    }

    function createMagicSparkles(x, y) {
      for (let i = 0; i < 5; i++) {
        const particle = {
          x: x + (Math.random() - 0.5) * 40,
          y: y + (Math.random() - 0.5) * 40,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          life: 1,
          type: 'sparkle'
        };
        particles.push(particle);
      }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.life -= 0.02;
        
        if (particle.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    function drawParticles() {
      particles.forEach(particle => {
        ctx.save();
        ctx.globalAlpha = particle.life;
        
        if (particle.type === 'spell') {
          ctx.fillStyle = `hsl(${45 + particle.life * 30}, 100%, 50%)`;
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, 4 * particle.life, 0, Math.PI * 2);
          ctx.fill();
        } else if (particle.type === 'death') {
          ctx.fillStyle = `hsl(${0 + particle.life * 30}, 100%, 50%)`;
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, 3 * particle.life, 0, Math.PI * 2);
          ctx.fill();
        } else if (particle.type === 'sparkle') {
          ctx.fillStyle = '#FFD700';
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, 2 * particle.life, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
      });
    }

    // Visual Effects Functions
    function addScreenShake(intensity) {
      screenShake = intensity;
      document.body.classList.add('screen-shake');
      setTimeout(() => {
        document.body.classList.remove('screen-shake');
      }, 300);
    }

    function showLevelTransition() {
      const transition = document.getElementById('levelTransition');
      transition.classList.add('active');
      audioManager.playTeleport();
      
      // Ensure transition is removed after animation
      setTimeout(() => {
        if (transition && transition.classList.contains('active')) {
          transition.classList.remove('active');
        }
      }, 1000);
      
      // Additional safety check
      setTimeout(() => {
        if (transition && transition.classList.contains('active')) {
          transition.classList.remove('active');
        }
      }, 2000);
    }

    function showAchievement(text) {
      const container = document.getElementById('achievementContainer');
      const achievement = document.createElement('div');
      achievement.className = 'achievement';
      // Split icon and text if present
      let icon = '';
      let message = text;
      const match = text.match(/([\uD800-\uDBFF][\uDC00-\uDFFF]|[\u2600-\u27BF]|[\uD83C-\uDBFF\uDC00-\uDFFF]+)\s*(.*)/);
      if (match) {
        icon = match[1];
        message = match[2];
      }
      achievement.innerHTML = `<span class="icon">${icon}</span><span class="text">${message}</span>`;
      container.appendChild(achievement);
      // Slide in
      setTimeout(() => achievement.classList.add('slide-in'), 10);
      // Slide out after 2.5s
      setTimeout(() => {
        achievement.classList.remove('slide-in');
        achievement.classList.add('slide-out');
      }, 2500);
      // Remove from DOM after animation
      setTimeout(() => {
        if (achievement.parentNode) container.removeChild(achievement);
      }, 3200);
    }

    // Enhanced UI Update Functions
    function updateHealthBar() {
      const healthFill = document.getElementById('healthFill');
      const healthPercent = (lives / 3) * 100;
      healthFill.style.width = healthPercent + '%';
      
      // if (lives < 3) {
      //   addScreenShake(3); // Removed screen shake
      // }
    }

    function updateLevelProgressBar() {
      const progressFill = document.getElementById('levelProgressFill');
      const progressPercent = (levelScore / levelTarget) * 100;
      progressFill.style.width = progressPercent + '%';
    }

    function updateScoreDisplay() {
      const scoreDisplay = document.getElementById('scoreDisplay');
      scoreDisplay.textContent = `Score: ${score}`;
      
      // Achievement system
      if (score >= 50 && lastAchievement < 50) {
        showAchievement('🎯 Sharp Shooter!');
        lastAchievement = 50;
      } else if (score >= 100 && lastAchievement < 100) {
        showAchievement('⚡ Lightning Fast!');
        lastAchievement = 100;
      } else if (score >= 150 && lastAchievement < 150) {
        showAchievement('🌟 Master Wizard!');
        lastAchievement = 150;
      }
    }

    // Parallax Background Effect
    function updateParallax() {
      parallaxOffset += 0.5;
      const layers = document.querySelectorAll('.parallax-bg');
      layers.forEach((layer, index) => {
        const speed = (index + 1) * 0.5;
        layer.style.transform = `translateX(${parallaxOffset * speed}px)`;
      });
    }

    // Spawning
    let lastDeathEaterSpawn = 0;
    let lastWitchSpawn = 0;
    let deathEaterInterval = levelConfig[currentLevel].deathEaterInterval;
    let witchInterval = levelConfig[currentLevel].witchInterval;

    function spawnDeathEater() {
      const winW = window.innerWidth;
      const winH = window.innerHeight;
      const border = Math.floor(Math.random() * 4);
      let x, y;
      if (border === 0) { x = Math.random() * winW; y = 0; }
      else if (border === 1) { x = winW; y = Math.random() * winH; }
      else if (border === 2) { x = Math.random() * winW; y = winH; }
      else { x = 0; y = Math.random() * winH; }
      const canvasRect = canvas.getBoundingClientRect();
      const cx = (x - canvasRect.left) * (canvas.width / canvasRect.width);
      const cy = (y - canvasRect.top) * (canvas.height / canvasRect.height);
      const angle = Math.atan2(centerY - cy, centerX - cx);
      deathEaters.push({
        x: cx, y: cy, w: 48, h: 48,
        speed: (2 + Math.random()*1.5) * levelConfig[currentLevel].enemySpeed,
        dx: Math.cos(angle),
        dy: Math.sin(angle)
      });
    }

    function spawnWitch() {
      const winW = window.innerWidth;
      const winH = window.innerHeight;
      const border = Math.floor(Math.random() * 4);
      let x, y;
      if (border === 0) { x = Math.random() * winW; y = 0; }
      else if (border === 1) { x = winW; y = Math.random() * winH; }
      else if (border === 2) { x = Math.random() * winW; y = winH; }
      else { x = 0; y = Math.random() * winH; }
      const canvasRect = canvas.getBoundingClientRect();
      const cx = (x - canvasRect.left) * (canvas.width / canvasRect.width);
      const cy = (y - canvasRect.top) * (canvas.height / canvasRect.height);
      const angle = Math.atan2(centerY - cy, centerX - cx);
      witches.push({
        x: cx, y: cy, w: 64, h: 64,
        speed: (1.5 + Math.random()*1) * levelConfig[currentLevel].witchSpeed,
        dx: Math.cos(angle),
        dy: Math.sin(angle),
        angle: angle,
        flyOffset: Math.random() * Math.PI * 2
      });
    }

    // Drawing
    function drawImageOrRect(img, x, y, w, h, angle = 0) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      if (img.complete && img.naturalWidth !== 0) {
        ctx.drawImage(img, -w/2, -h/2, w, h);
      } else {
        ctx.fillStyle = img.fallbackColor;
        ctx.fillRect(-w/2, -h/2, w, h);
      }
      ctx.restore();
    }

    function drawHarry() {
      drawImageOrRect(harryImg, harry.x, harry.y, harry.w, harry.h, harry.angle - Math.PI / 2);
    }

    function drawSpells() {
      for (let i = 0; i < spells.length; i++) {
        drawImageOrRect(spellImg, spells[i].x, spells[i].y, spells[i].w, spells[i].h);
      }
    }

    function drawDeathEaters() {
      for (let i = 0; i < deathEaters.length; i++) {
        drawImageOrRect(deImg, deathEaters[i].x, deathEaters[i].y, deathEaters[i].w, deathEaters[i].h);
      }
    }

    function drawWitches() {
      for (let i = 0; i < witches.length; i++) {
        const witch = witches[i];
        const t = Date.now() / 400 + witch.flyOffset;
        const bob = Math.sin(t) * 10;
        ctx.save();
        ctx.translate(witch.x, witch.y + bob);

        if (witch.dx < 0 && witch.x > centerX) {
          ctx.rotate(witch.angle);
          const img = (witchRImg.complete && witchRImg.naturalWidth !== 0) ? witchRImg : witchImg;
          ctx.drawImage(img, -witch.w/2, -witch.h/2, witch.w, witch.h);
        } else {
          if (witch.dx < 0) {
            ctx.rotate(witch.angle + Math.PI);
            ctx.scale(1, -1);
          } else {
            ctx.rotate(witch.angle);
          }
          if (witchImg.complete && witchImg.naturalWidth !== 0) {
            ctx.drawImage(witchImg, -witch.w/2, -witch.h/2, witch.w, witch.h);
          } else {
            ctx.fillStyle = witchImg.fallbackColor;
            ctx.fillRect(-witch.w/2, -witch.h/2, witch.w, witch.h);
          }
        }
        ctx.restore();
      }
    }

    // Load the enemy death sound and set its volume lower
    const enemyDeadAudio = new Audio('enemy_dead.mp3');
    enemyDeadAudio.volume = 0.3;

    // Level progression function
    function checkLevelProgress() {
      if (levelScore >= levelTarget) {
        if (currentLevel < 3) {
          // Pause the game loop temporarily
          gameStarted = false;
          
          // Level up
          currentLevel++;
          levelScore = 0;
          levelTarget = levelConfig[currentLevel].target;
          deathEaterInterval = levelConfig[currentLevel].deathEaterInterval;
          witchInterval = levelConfig[currentLevel].witchInterval;
          
          // Enhanced level transition
          showLevelTransition();
          showAchievement(`🎉 Level ${currentLevel} Complete! 🎉`);
          
          // Clear all enemies for level transition
          deathEaters.length = 0;
          witches.length = 0;
          spells.length = 0;
          particles.length = 0;
          
          // Update UI
          updateUI();
          
          // Resume game after transition
          setTimeout(() => {
            gameStarted = true;
            requestAnimationFrame(updateAndDraw);
          }, 1500); // Wait 1.5 seconds for transition
          
        } else {
          // Game completed - redirect to won page
          stopDynamicBackground();
          const audio = document.getElementById('bg-music');
          if (audio) {
            audio.pause();
          }
          showAchievement('🏆 Game Complete! 🏆');
          setTimeout(() => {
            window.location.href = `won.html?score=${score}&level=${currentLevel}`;
          }, 2000);
        }
      }
    }

    // Update UI elements
    function updateUI() {
      const levelDisplay = document.getElementById('levelDisplay');
      
      levelDisplay.textContent = `Level: ${currentLevel}`;
    }

    // Main update and draw loop
    function updateAndDraw(now) {
      // Only run if game is started and not over
      if (!gameStarted || gameOver) {
        return;
      }
      
      try {
        // Spawn Death Eaters
        if (now - lastDeathEaterSpawn > deathEaterInterval) {
          spawnDeathEater();
          lastDeathEaterSpawn = now;
        }
        // Spawn Witches (start spawning witches from level 2)
        if (currentLevel >= 2 && now - lastWitchSpawn > witchInterval) {
          spawnWitch();
          lastWitchSpawn = now;
        }

        // Update particles
        updateParticles();
        
        // Update parallax background
        updateParallax();

        // Move spells
        for (let i = spells.length - 1; i >= 0; i--) {
          const spell = spells[i];
          spell.x += spell.dx * spell.speed;
          spell.y += spell.dy * spell.speed;
          if (
            spell.x < -20 || spell.x > canvas.width + 20 ||
            spell.y < -20 || spell.y > canvas.height + 20
          ) {
            spells.splice(i, 1);
          }
        }

        // Move Death Eaters
        for (let i = deathEaters.length - 1; i >= 0; i--) {
          const de = deathEaters[i];
          de.x += de.dx * de.speed;
          de.y += de.dy * de.speed;
          // Collision with Harry
          if (Math.hypot(de.x - harry.x, de.y - harry.y) < 40) {
            deathEaters.splice(i, 1);
            lives--;
            audioManager.playDeath();
            if (lives <= 0) {
              gameOver = true;
              showGameOverMenu();
              return;
            }
            continue;
          }
          // Collision with spells
          for (let j = spells.length - 1; j >= 0; j--) {
            if (Math.hypot(de.x - spells[j].x, de.y - spells[j].y) < 32) {
              deathEaters.splice(i, 1);
              spells.splice(j, 1);
              score++;
              levelScore++;
              // Enhanced death effects
              createDeathParticles(de.x, de.y);
              createMagicSparkles(de.x, de.y);
              // Play enemy death sound
              enemyDeadAudio.currentTime = 0;
              enemyDeadAudio.play();
              // Check level progress
              checkLevelProgress();
              break;
            }
          }
        }

        // Move Witches
        for (let i = witches.length - 1; i >= 0; i--) {
          const witch = witches[i];
          witch.x += witch.dx * witch.speed;
          witch.y += witch.dy * witch.speed;
          // Collision with Harry
          if (Math.hypot(witch.x - harry.x, witch.y - harry.y) < 40) {
            witches.splice(i, 1);
            lives--;
            audioManager.playDeath();
            if (lives <= 0) {
              gameOver = true;
              showGameOverMenu();
              return;
            }
            continue;
          }
          // Collision with spells
          for (let j = spells.length - 1; j >= 0; j--) {
            if (Math.hypot(witch.x - spells[j].x, witch.y - spells[j].y) < 32) {
              witches.splice(i, 1);
              spells.splice(j, 1);
              score++;
              levelScore++;
              // Enhanced death effects
              createDeathParticles(witch.x, witch.y);
              createMagicSparkles(witch.x, witch.y);
              // Play enemy death sound
              enemyDeadAudio.currentTime = 0;
              enemyDeadAudio.play();
              // Check level progress
              checkLevelProgress();
              break;
            }
          }
        }

        // Update enhanced UI
        if (!gameOver) {
          scoreboard.textContent = "Score: " + score + "  |  Lives: " + lives;
          updateUI();
          updateHealthBar();
          updateLevelProgressBar();
          updateScoreDisplay();
        }

        // Draw everything
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawHarry();
        drawSpells();
        drawDeathEaters();
        drawWitches();
        drawParticles();

        // Continue the loop only if game is still active
        if (gameStarted && !gameOver) {
          requestAnimationFrame(updateAndDraw);
        }
        
      } catch (error) {
        console.error('Error in game loop:', error);
        // Try to recover and continue
        if (gameStarted && !gameOver) {
          requestAnimationFrame(updateAndDraw);
        }
      }
    }

    // Start menu logic
    function startGame() {
      if (!gameStarted) {
        gameStarted = true;
        gameOver = false; // Reset game over state
        document.getElementById('startMenu').style.display = 'none';
        const audio = document.getElementById('bg-music');
        if (audio) {
          audio.volume = 0.5;
          audio.play().catch(() => {});
        }
        // Initialize level configuration
        currentLevel = 1;
        levelScore = 0;
        levelTarget = levelConfig[currentLevel].target;
        deathEaterInterval = levelConfig[currentLevel].deathEaterInterval;
        witchInterval = levelConfig[currentLevel].witchInterval;
        
        // Initialize enhanced features
        particles = [];
        screenShake = 0;
        lastAchievement = 0;
        parallaxOffset = 0;
        
        // Initialize dynamic background
        initDynamicBackground();
        
        // Show starting achievement
        setTimeout(() => {
          showAchievement('✨ Let the Magic Begin! ✨');
        }, 1000);
        
        updateUI();
        
        // Ensure game loop starts
        if (gameStarted && !gameOver) {
          requestAnimationFrame(updateAndDraw);
        }
      }
    }
    document.getElementById('startBtn').onclick = startGame;

    // Show game over menu and retry button when game ends
    function showGameOverMenu() {
      stopDynamicBackground();
      const audio = document.getElementById('bg-music');
      if (audio) {
        audio.pause();
      }
      document.getElementById('finalScore').textContent = "Final Score: " + score;
      document.getElementById('gameOverMenu').style.display = 'flex';
    }

    // Retry button logic: refresh the page on click
    document.getElementById('retryBtn').onclick = function() {
      location.reload();
    };

    // Responsive: keep Harry centered on resize
    window.addEventListener('resize', () => {
      harry.x = canvas.width / 2;
      harry.y = canvas.height / 2;
    });

    // Dynamic Background System
    function initDynamicBackground() {
      const backgrounds = [
        document.getElementById('bg1'),
        document.getElementById('bg2'),
        document.getElementById('bg3'),
        document.getElementById('bg4')
      ];
      
      function changeBackground() {
        // Remove active class from current background
        backgrounds[currentBgIndex].classList.remove('bg-active');
        
        // Move to next background
        currentBgIndex = (currentBgIndex + 1) % backgrounds.length;
        
        // Add active class to new background
        backgrounds[currentBgIndex].classList.add('bg-active');
        
        // Random interval between 10-15 seconds
        const nextInterval = Math.random() * 5000 + 10000; // 10-15 seconds
        
        // Schedule next change
        bgChangeInterval = setTimeout(changeBackground, nextInterval);
      }
      
      // Start the background cycling
      const initialInterval = Math.random() * 5000 + 10000; // 10-15 seconds
      bgChangeInterval = setTimeout(changeBackground, initialInterval);
    }
    
    function stopDynamicBackground() {
      if (bgChangeInterval) {
        clearTimeout(bgChangeInterval);
        bgChangeInterval = null;
      }
    }

    // Magical cursor functionality
    function initMagicalCursor() {
      const cursor = document.getElementById('magicalCursor');
      let mouseX = 0, mouseY = 0;
      let cursorX = 0, cursorY = 0;
      let trailElements = [];
      let lastTrailTime = 0;

      // Track mouse movement
      document.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
        
        // Create trail effect
        const now = Date.now();
        if (now - lastTrailTime > 50) { // Create trail every 50ms
          createTrail(mouseX, mouseY);
          lastTrailTime = now;
        }
        
        // Create spell particles randomly
        if (Math.random() < 0.1) { // 10% chance per frame
          createSpellParticle(mouseX, mouseY);
        }
        
        // Create sparkles occasionally
        if (Math.random() < 0.05) { // 5% chance per frame
          createSparkle(mouseX, mouseY);
        }
      });

      // Smooth cursor movement
      function updateCursor() {
        cursorX += (mouseX - cursorX) * 0.15;
        cursorY += (mouseY - cursorY) * 0.15;
        
        cursor.style.left = cursorX - 12 + 'px';
        cursor.style.top = cursorY - 12 + 'px';
        
        requestAnimationFrame(updateCursor);
      }
      
      updateCursor();

      // Create trail effect
      function createTrail(x, y) {
        const trail = document.createElement('div');
        trail.style.left = x - 4 + 'px';
        trail.style.top = y - 4 + 'px';
        trail.className = 'cursor-trail';
        document.body.appendChild(trail);
        
        // Remove trail after animation
        setTimeout(() => {
          if (trail.parentNode) {
            trail.parentNode.removeChild(trail);
          }
        }, 800);
      }

      // Create spell particle
      function createSpellParticle(x, y) {
        const particle = document.createElement('div');
        particle.style.left = x + (Math.random() - 0.5) * 20 + 'px';
        particle.style.top = y + (Math.random() - 0.5) * 20 + 'px';
        particle.className = 'spell-particle';
        document.body.appendChild(particle);
        
        // Remove particle after animation
        setTimeout(() => {
          if (particle.parentNode) {
            particle.parentNode.removeChild(particle);
          }
        }, 1500);
      }

      // Create sparkle effect
      function createSparkle(x, y) {
        const sparkle = document.createElement('div');
        sparkle.style.left = x + (Math.random() - 0.5) * 30 + 'px';
        sparkle.style.top = y + (Math.random() - 0.5) * 30 + 'px';
        sparkle.className = 'sparkle';
        document.body.appendChild(sparkle);
        
        // Remove sparkle after animation
        setTimeout(() => {
          if (sparkle.parentNode) {
            sparkle.parentNode.removeChild(sparkle);
          }
        }, 1000);
      }

      // Cursor hover effects
      document.addEventListener('mouseenter', () => {
        cursor.style.transform = 'scale(1.3)';
        cursor.style.boxShadow = '0 0 20px #FFD700, 0 0 40px #FFA500';
      });

      document.addEventListener('mouseleave', () => {
        cursor.style.transform = 'scale(0.8)';
        cursor.style.boxShadow = '0 0 15px #FFD700, 0 0 30px #FFA500';
      });

      // Click effects
      document.addEventListener('mousedown', () => {
        cursor.style.transform = 'scale(1.8)';
        cursor.style.background = 'radial-gradient(circle, #FF6347, #FF8C00)';
        cursor.style.boxShadow = '0 0 25px #FF6347, 0 0 50px #FF8C00';
        
        // Create extra particles on click
        for (let i = 0; i < 5; i++) {
          setTimeout(() => {
            createSpellParticle(mouseX, mouseY);
            createSparkle(mouseX, mouseY);
          }, i * 50);
        }
      });

      document.addEventListener('mouseup', () => {
        cursor.style.transform = 'scale(1)';
        cursor.style.background = 'radial-gradient(circle, #FFD700, #FFA500)';
        cursor.style.boxShadow = '0 0 15px #FFD700, 0 0 30px #FFA500';
      });

      // Wheel effects
      document.addEventListener('wheel', () => {
        cursor.style.transform = 'scale(0.7)';
        setTimeout(() => {
          cursor.style.transform = 'scale(1)';
        }, 100);
      });
    }

    // Initialize magical cursor when page loads
    window.addEventListener('load', () => {
      initMagicalCursor();
    });

    // --- Block Mobile/Tablet Users ---
    function isMobileOrTablet() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|Tablet|Windows Phone/i.test(navigator.userAgent);
    }
    if (isMobileOrTablet()) {
      document.body.innerHTML = `
        <div style="position:fixed;top:0;left:0;width:100vw;height:100vh;background:linear-gradient(135deg,#222 60%,#444 100%);display:flex;align-items:center;justify-content:center;z-index:99999;">
          <div style="background:rgba(30,20,60,0.95);border-radius:18px;padding:48px 36px;box-shadow:0 0 32px #000a;text-align:center;max-width:90vw;">
            <div style="font-size:2em;color:#FFD700;margin-bottom:18px;font-family:'Times New Roman',serif;">Desktop Only</div>
            <div style="font-size:1.2em;color:#fff;font-family:'Segoe UI',serif;">This magical game is only available on desktop devices.<br><br>Please visit from a desktop or laptop computer for the best experience!</div>
          </div>
        </div>
      `;
      // Prevent further script execution
      throw new Error('Mobile/Tablet access blocked.');
    }
  </script>
</body>
</html> 
